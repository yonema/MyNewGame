#include "stdafx.h"
#include "PlayerSwingAction.h"
#include "Player.h"
#include "PlayerMovement.h"
#include "StringActionTargetManager.h"

namespace nsMyGame
{
	/**
	 * @brief プレイヤー関連のネームスペース
	*/
	namespace nsPlayer
	{
		/**
		 * @brief プレイヤーの動き関連のネームスペース
		*/
		namespace nsPlayerMovenent
		{
			// プレイヤーのスイングアクションクラスの定数データを使用可能にする
			using namespace nsPlayerConstData::nsPlayerSwingActionConstData;


			/**
			 * @brief 初期化
			 * @param[in,out] player プレイヤー
			 * @param[in,out] playerMovement プレイヤー移動クラスの参照
			*/
			void CPlayerSwingAction::Init(
				CPlayer* player,
				CPlayerMovement* playerMovement
			)
			{
				// プレイヤーの参照をセット
				m_playerRef = player;
				// 加算移動ベクトルの参照をセット
				m_playerMovementRef = playerMovement;

				return;
			}

			/**
			 * @brief スイングアクションを実行
			*/
			void CPlayerSwingAction::Execute()
			{
				nsDebug::DrawTextPanel(L"[SwingAction:Execute]");

				// スイングターゲットを探すか？
				if (m_swingActionState == enFindSwingTarget)
				{
					// スイングターゲットを探す
					FindSwingTarget();
				}

				// スイングアクションをやめたか？
				if (m_playerRef->GetInputData().actionSwing != true)
				{
					if (m_swingActionState == EnSwingActionState::enIsSwinging)
					{
						m_accelerationAfterSwing = kInitialVelocityOfAterSwingAcceleration;
						
						m_velocityAfterSwing = m_playerMovementRef->GetVelocity();
						m_inputMoveDirXZ = Vector3::Zero;
					}
					// ステートをスイング後の空中状態に遷移する
					m_swingActionState = EnSwingActionState::enIsAirAfterSwing;
					// 糸に終了を知らせる
					m_playerRef->EndStringStretchToPos();
				}

				// 地面についてしまったか？
				if (m_playerMovementRef->IsAir() != true)
				{
					// スイングアクションを終了する
					m_swingActionState = EnSwingActionState::enEnd;
				}

				// スイング中の処理をステートで割り振る
				switch (m_swingActionState)
				{
				// 糸を伸ばしている最中
				case enIsStringStretching:
					// 糸を伸ばしている最終の処理
					StringStretching();
					break;

				// スイング中
				case enIsSwinging:
					// スイング中の処理
					SwingAction();
					break;

				// スイング後の空中
				case enIsAirAfterSwing:
					// スイング後の空中の処理
					AirAfterSwing();
					break;

				// スイング終了
				case enEnd:
					// スイング処理の終了
					EndSwing();
					break;
				}

				return;
			}


			/**
			 * @brief スイングターゲットを探す
			*/
			void CPlayerSwingAction::FindSwingTarget()
			{
				// スイングターゲットへの距離
				float dist = FLT_MAX;

				// スイングターゲットを初期化
				m_swingTargetPos = nullptr;

				// 複数の座標から、スイングターゲットを探す
				for (int i = 0; i < kFindSwintTargetNum; i++)
				{
					// スイングターゲットを探す座標へのベクトル
					Vector3 toFindSwingTargetVec = kToFindSwingTargetVecs[i];
					// プレイヤーのモデルの向きに回転させる
					m_playerRef->GetRotation().Apply(toFindSwingTargetVec);

					// 指定された座標から有効範囲内にあるスイングターゲットの座標の中で一番近い座標を得る
					const Vector3* swingTargetPos = 
						nsStringActionTarget::GetNearestSwintTargetPointWithinScope(
						m_playerRef->GetPosition() + toFindSwingTargetVec, kFindSwingTargetScope
					);

					// スイングターゲットの座標がnullptrか？
					if (swingTargetPos == nullptr)
					{
						// 見つからなかった。次へ。
						continue;
					}

					// プレイヤーからスイングターゲットへのベクトル
					Vector3 toSwingTargetVec = *swingTargetPos - m_playerRef->GetPosition();
					// プレイヤーからスイングターゲットへの方向ベクトル
					Vector3 toSwingTargetDir = toSwingTargetVec;
					toSwingTargetDir.Normalize();	// 正規化する

					// 前方向ベクトル
					Vector3 forward = Vector3::Front;
					// プレイヤーのモデルの向きに回転させる
					m_playerRef->GetRotation().Apply(forward);
					forward.Normalize();	// 正規化する

					// スイングターゲットへの方向ベクトルと、前方向ベクトルの内積が負か？
					if (Dot(toSwingTargetDir, forward) <= 0.0f)
					{
						// 負。スイングターゲットがプレイヤーの後ろにあるからパス。次へ。
						continue;
					}

					// 優先度が高いスイングターゲットか？
					if (i < kHighPriorityFindSwintTargetNum)
					{
						// 優先度が高いから、見つけたら即座に終了。
						// スイングターゲットの座標を保持
						m_swingTargetPos = swingTargetPos;
						break;
					}
					else
					{
						// 普通の優先度は、プレイヤーから距離が近いスイングターゲットが優先される。

						// 今回の距離ベクトル
						const Vector3 newDistVec = *swingTargetPos - m_playerRef->GetPosition();
						// 今回の距離
						const float newDist = newDistVec.Length();

						// 今回の距離が今までの最短距離より大きいか？
						if (newDist > dist)
						{
							// 大きい。優先度低。次へ。
							continue;
						}
						// 近いスイングターゲットのため、優先度高。
						// 最短距離を保持
						dist = newDist;
						// スイングターゲットの座標を保持
						m_swingTargetPos = swingTargetPos;
					}

				}

				// スイングターゲットが見つかったか？
				if (m_swingTargetPos != nullptr)
				{
					// 見つかった
					// 糸をスイングターゲットに向かって伸ばし始める
					m_playerRef->StartStringStretchToPos(*m_swingTargetPos);
					// ステートを糸を伸ばし中へ遷移する
					m_swingActionState = EnSwingActionState::enIsStringStretching;
				}
				else
				{
					// 見つからなかった
					// ステートを終了へ遷移する
					m_swingActionState = EnSwingActionState::enIsAirAfterSwing;
				}

				return;
			}

			/**
			 * @brief 糸を伸ばしている最中の処理
			*/
			void CPlayerSwingAction::StringStretching()
			{
				nsDebug::DrawTextPanel(L"StringStretching");
				// 伸びきってないか？
				if (m_playerRef->IsStringStretched() != true)
				{
					// まだ伸びきってない。早期リターン
					return;
				}

				//////// 糸が伸びきった。スイングをする準備をする ////////

				//////// ステート遷移 ////////
				// 伸ばし切ったから、ステートをスイング中に遷移
				m_swingActionState = EnSwingActionState::enIsSwinging;

				//////// パラメータのリセット ////////
				// 減速し始めるスイングスピードを初期化する
				m_startDecelerateSwingSpeed = kStartDecelerateSwingSpeedInitialValue;
				// 入力によって生じたXZ平面での移動方向を初期化する
				m_inputMoveDirXZ = Vector3::Zero;

				if (m_playerRef->GetPosition().y < m_swingTargetPos->y)
				{
					m_swingStartYPos = m_playerRef->GetPosition().y;
				}
				else
				{
					m_swingStartYPos = m_swingTargetPos->y;
				}
				m_swingMinYPos = max(100.0f, m_swingStartYPos - 500.0f);
				m_swingStringLen = m_playerRef->GetStringLength();

				//////// スイングスピードの初期速度の計算 ////////
				// スイングスピードが初期速度より遅いか？
				//if (m_swingSpeed <= kInitialSwingSpeed)
				{
					// 遅い。初期速度のスイングスピードを設定する。落下速度が速いとスイングスピードも速くなる。
					m_swingSpeed = kInitialSwingSpeed +
						fabsf(m_playerMovementRef->GetMoveVec().y) * kFallImpactRateForInitialSwingSpeed;

					// 早期リターン
					return;
				}

				// やっぱ加速しない、この下通らない。
				//////// スイングスピードの加速したスピードを計算 ////////

				// 前回のスイングスピードからの加速
				float acceleration = m_playerMovementRef->GetVelocity() - m_swingSpeed;
				// 前回から、加速があるか？
				if (acceleration >= 0.0f)
				{
					// 加速がある。加速の一部を引き継いで加算する
					m_swingSpeed += acceleration * kTakeOverSwingAccelerationRate;
				}
				else
				{
					// 減速している
					// 現在の速度をスイングスピードにする
					m_swingSpeed = m_playerMovementRef->GetVelocity();
				}

				// スイングスピードが最大速度を超えているか？
				if (m_swingSpeed > kMaxSwingSpeed)
				{
					// 超えている。最大速度に設定する。
					m_swingSpeed = kMaxSwingSpeed;
				}

				return;
			}

			/**
			 * @brief スイングアクションの処理
			*/
			void CPlayerSwingAction::SwingAction()
			{
				nsDebug::DrawTextPanel(L"SwingAction");
				
				// プレイヤーからスイングターゲットまでのXZ平面でのベクトル
				Vector3 playerToTargetVecXZ = *m_swingTargetPos - m_playerRef->GetPosition();
				// Y成分を消去
				playerToTargetVecXZ.y = 0.0f;

				// XZ平面での前方向
				Vector3 forwardDirXZ = Vector3::Front;
				// モデルの向きに回す
				m_playerRef->GetRotation().Apply(forwardDirXZ);
				// 正規化する
				forwardDirXZ.Normalize();				

				// XZ平面の前方向に、プレイヤーからスイングターゲットへのXZ平面のベクトルを射影する
				float projectToTargetVecXZToForwardDirXZ = Dot(forwardDirXZ, playerToTargetVecXZ);

				// XZ平面での、前方向のみの、スイングターゲットへのベクトル
				Vector3 toTargetFowardVecXZ = forwardDirXZ;
				// 射影して求めた長さまで伸ばす
				toTargetFowardVecXZ.Scale(projectToTargetVecXZToForwardDirXZ);

				// XZ平面での、前方向のみの、スイングターゲットの座標
				const Vector3 toTargetForwardPosXZ = m_playerRef->GetPosition() + toTargetFowardVecXZ;

				// 前方向と上方向のみの、スイングターゲットの座標
				Vector3 toTargetForwardUpPos = toTargetForwardPosXZ;
				// Y座標を実際のスイングターゲットの座標と同じにする
				toTargetForwardUpPos.y = m_swingTargetPos->y;

				// 前方向と上方向のみのスイングターゲットの座標からプレイヤーへのベクトル
				const Vector3 toTargetForwardUpToPlayerVec = m_playerRef->GetPosition() - toTargetForwardUpPos;
				
				// 前方向と上方向のみのスイングターゲットの座標からプレイヤーへの方向
				Vector3 targetUptoPlayerDir = toTargetForwardUpToPlayerVec;
				// 正規化する
				targetUptoPlayerDir.Normalize();

				// XZ平面での前方向と、スイングターゲットからプレイヤーへの方向の内積
				float dotFowardDirXZAndToPlayerDir = 
					Dot(forwardDirXZ, targetUptoPlayerDir);

				// 加算移動方向ベクトル
				Vector3 addMoveDir = targetUptoPlayerDir;

				// 加算移動方向ベクトルを回転させる回転クォータニオン
				Quaternion qRotForAddMoveDir;

				// 加算移動方向ベクトルを回転させる回転軸。
				Vector3 rotAxisForAddMoveDir = Cross(targetUptoPlayerDir, forwardDirXZ);

				// プレイヤーがスイングターゲットより上にいるか？
				if (m_playerRef->GetPosition().y >= m_swingTargetPos->y)
				{
					// 上にいるとき、回転軸の求め方を変える
					rotAxisForAddMoveDir = Cross(Vector3::Down, forwardDirXZ);
				}

				// 求めた回転軸を正規化する
				rotAxisForAddMoveDir.Normalize();

				// 内積が負か？、つまり、スイングターゲットより手前側にいるか？
				if (dotFowardDirXZAndToPlayerDir < 0.0f)
				{
					// 手前側

					float rate = dotFowardDirXZAndToPlayerDir + 1.0f;
					rate = pow(rate, 5.0f);
/*					if (m_playerRef->GetPosition().y >= m_swingTargetPos->y)
					{
						addMoveDir = forwardDirXZ;
						addMoveDir.y -= 10.0f;

					}
					else */if (m_playerRef->GetPosition().y > 100.0f)
					{
						//// 回転クォータニオンを90度回転させる
						//qRotForAddMoveDir.SetRotation(rotAxisForAddMoveDir, 3.14f * 0.5f);
						//// 加算移動方向ベクトルを回転させる
						//qRotForAddMoveDir.Apply(addMoveDir);

						addMoveDir = forwardDirXZ;
						rate = 1.0f - rate;
						float radAngle = 3.14f * 0.1f * -rate;
						// 回転クォータニオンを90度回転させる
						qRotForAddMoveDir.SetRotation(rotAxisForAddMoveDir, radAngle);
						// 加算移動方向ベクトルを回転させる
						qRotForAddMoveDir.Apply(addMoveDir);
					}
					else
					{
						addMoveDir = forwardDirXZ;
					}


				}
				else
				{
					// 奥側

					float radAngle = 3.14f * 0.5f;
					Vector3 to = m_playerRef->GetPosition() - toTargetForwardPosXZ;
					//float rate = to.Length() / toTargetForwardUpToPlayerVec.Length();
					float rate = toTargetFowardVecXZ.Length() / m_swingStringLen;
					rate = min(rate, 1.0f);
					rate = pow(rate, 4.0f);
					//rate = min(rate, 3.14f * 0.5f);

					if (m_playerRef->GetPosition().y >= m_swingTargetPos->y)
					{
						if (m_startDecelerateSwingSpeed <= -50.0f)
						{
							m_startDecelerateSwingSpeed = m_swingSpeed;
						}
						float dot = Dot(forwardDirXZ, targetUptoPlayerDir);
						float rad = acosf(dot);
						float angleRate = rad / (3.14f * 0.1f);
						m_swingSpeed = Math::Lerp<float>(min(1.0f,angleRate), m_startDecelerateSwingSpeed, 0.0f);
						addMoveDir = forwardDirXZ;
						radAngle = 3.14f * 0.5f * min(1.0f, angleRate);
						radAngle = Math::Lerp<float>(min(1.0f, angleRate), 3.14f * 0.4f, 3.14f * 0.5f);


					}
					else
					{

						addMoveDir = forwardDirXZ;
						radAngle = 3.14f * 0.4f * rate;

					}

					// 回転クォータニオンを90度回転させる
					qRotForAddMoveDir.SetRotation(rotAxisForAddMoveDir, radAngle);
					// 加算移動方向ベクトルを回転させる
					qRotForAddMoveDir.Apply(addMoveDir);

				}

				nsDebug::DrawTextPanel(std::to_wstring(m_swingStringLen), L"stringLen");

				Vector3 rightDirXZ = m_playerRef->GetCamera().GetCameraRight();
				rightDirXZ.y = 0.0f;
				rightDirXZ.Normalize();
				float rightPower = m_playerRef->GetInputData().axisMoveRight / 5.0f;
				rightDirXZ.Scale(rightPower);
				m_inputMoveDirXZ.Lerp(0.2f, m_inputMoveDirXZ, rightDirXZ);

				addMoveDir += m_inputMoveDirXZ;

				addMoveDir.Normalize();

				// 加算移動ベクトル
				Vector3 addMoveVec = addMoveDir;
				addMoveVec.Scale(m_swingSpeed);

				m_playerMovementRef->ResetMoveVecX();
				m_playerMovementRef->ResetMoveVecY();
				m_playerMovementRef->ResetMoveVecZ();

				// 移動ベクトルに、加算移動ベクトルを加算する
				m_playerMovementRef->AddMoveVec(addMoveVec);

				Vector3 dist = m_playerRef->GetPosition() - *m_swingTargetPos;
				nsDebug::DrawTextPanel(std::to_wstring(dist.Length()), L"toSwintTargetLen:");

				return;
			}


			/**
			 * @brief スイング後の空中の処理
			*/
			void CPlayerSwingAction::AirAfterSwing()
			{
				nsDebug::DrawTextPanel(L"AirAfterSwing");
				if (m_playerRef->GetInputData().triggerSwing == true)
				{
					m_swingActionState = enFindSwingTarget;
				}

				Vector3 addVec = Vector3::Zero;
				Vector3 moveVec = m_playerMovementRef->GetMoveVec();
				Vector3 moveVecXZ = moveVec;
				moveVecXZ.y = 0.0f;
				Vector3 addMoveDir = moveVecXZ;
				addMoveDir.Normalize();
				m_accelerationAfterSwing *= 0.99f;
				if (m_accelerationAfterSwing < kMinVelocityOfAfterSwingAcceleration)
				{
					m_accelerationAfterSwing = kMinVelocityOfAfterSwingAcceleration;
				}
				float velocity = m_velocityAfterSwing + m_accelerationAfterSwing;


				if (velocity < nsPlayerConstData::nsPlayerWalkAndRunConstData::kWalkMaxSpeed)
				{
					velocity = nsPlayerConstData::nsPlayerWalkAndRunConstData::kWalkMaxSpeed;
				}

				if (m_playerRef->GetInputData().inputMoveAxis)
				{

					Vector3 rightDirXZ = m_playerRef->GetCamera().GetCameraRight();
					rightDirXZ.y = 0.0f;
					rightDirXZ.Normalize();
					float rightPower = m_playerRef->GetInputData().axisMoveRight / 7.0f;
					rightDirXZ.Scale(rightPower);
					m_inputMoveDirXZ.Lerp(0.2f, m_inputMoveDirXZ, rightDirXZ);
					addMoveDir += m_inputMoveDirXZ;

					addMoveDir.Normalize();
					addVec = addMoveDir;
					addVec.Scale(velocity);
				}
				else
				{
					Vector3 moveDirXZ = moveVecXZ;
					moveDirXZ.Normalize();
					moveDirXZ.Scale(velocity);
					addVec = moveDirXZ;
				}

				m_playerMovementRef->ResetMoveVecX();
				m_playerMovementRef->ResetMoveVecZ();

				m_playerMovementRef->AddMoveVec(addVec);
				return;
			}

			/**
			 * @brief スイング処理の終了
			*/
			void CPlayerSwingAction::EndSwing()
			{
				// ステートをスイングターゲットを探す状態に戻しておく
				m_swingActionState = enFindSwingTarget;
				// 糸に終了を知らせる
				m_playerRef->EndStringStretchToPos();
				// プレイヤーのステートを歩きと走りにする
				m_playerRef->ChangeWalkAndRunState();
				m_swingSpeed = 0.0f;

				return;
			}

		}
	}
}